https://oi-wiki.org/dp/knapsack/

---

### 双指针
   
双指针算法是基于暴力解法的优化
- 对于数组，指两个变量在数组上相向移动解决的问题； 
- 对于链表，指两个变量在链表上**同向移动**解决的问题，也称为「**快慢指针**」问题。

---

### 链表

通常需要注意两点：
1. 舍得用变量，千万别想着节省变量，否则容易被逻辑绕晕
2. **head 有可能需要改动时，先增加一个 假head**，返回的时候直接取 假head.next，这样就不需要为修改 head 增加一大堆逻辑

---

### 并查集

并查集（Union-find Data Structure）是一种树型的数据结构。
它的特点是由子结点找到父亲结点，用于处理一些不交集（Disjoint Sets）的合并及查询问题。
Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。
Union：将两个子集合并成同一个集合。


---

### 前缀树

又称字典树。它是一棵 N 叉树。
前缀树用于存储、查找字符串。前缀树的每一个结点代表一个字符串的前缀。
每一个结点会有多个子结点，通往不同子结点的路径上有着不同的字符。
子结点代表的字符串是由结点本身的原始字符串 ，以及通往该子结点路径上所有的字符组成的。


---

### 前缀和

一般用在 子数组，子串 上，子数组遍历需要O(N^2)时间。

有时候结合哈希表来存放 要查找的值，使用O(N)的空间换取O(N)的时间

---

### 单调栈

   在一维数组中对每一个数找到第一个比自己小的元素，这类 “在一维数组中找满足某种条件的数” 的场景就是典型的单调栈应用场景。

---

### 堆 / 优先队列

   对于 每次需要从 容器 中找出 某次序的元素，或 对容器多次进行排序 的情况，时间复杂度为O(N)，可以构建一个优先队列存放元素，并指定comparator比较器，使用空间换取时间

---

### 动态规划 dp


#### 记忆化搜索

也叫记忆化递归。拆分子问题的时候，发现有很多重复子问题，然后再求解它们以后记录下来。以后再遇到要求解同样规模的子问题的时候，直接读取答案



---

### 位运算

- 格雷编码：对称法/公式法

